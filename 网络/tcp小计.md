## 一.TCP/IP网络分层
### 网络接口层
各种物理通信接口
### 网络层
IP、ICMP、ARP、RARP
### 传输层
TCP、UDP
### 应用层
http,ftp,telnet,smpp,xmpp
## 二.TCP
### <一>、定义
TCP是一个可靠的、面向连接的、基于字节流的、全双工的协议
### 面向连接
在正式发送数据之前需要通过三次握手建立建立一个逻辑连接，结束通信时需要通过四次挥手断开连接
###  TCP是可靠的
#### 1. 校验和机制
每个TCP包首部中都有两个字节用来表示校验和，防止传输过程中有损坏，当收到校验和有差错的报文，TCP不会发送任何确认直接丢弃，等待重传
#### 2.序列号机制
包的序列号保证了接收数据的乱序和重复问题
#### 3.超时重传
TCP发送数据后悔启动一个定时器，等待对端确认收到这个数据包，如果指定时间内没有收到ACK确认，就会重传数据包，再多次未收到ACK确认后就会丢弃这个包
#### 4.流量控制、拥塞控制

### <二>、TCP头部
源端口 |   目标端口
序列号
确认号
头部长度|保留|NS|CWR|ECE|URG|ACK|PSH|RST|FIN    |        窗口大小
校验和  |  紧急指针
选项
#### 1.序列号
1.通过TCP传输的字节流的每个字节都分配了序列号
2.序列号加上报文长度就可以确定是哪段数据
3.序列号是一个32位无符号整数达到2^32-1后循环到0
4.接收方根据序列号大小拼装数据
#### 2.初始序列号（ISN）
1、在刚开始建立连接的时候，双方各自选择一个序列号称为初始序列号，通过交换SYN报文交换彼此的ISN
2、序列号回绕怎么处理将无符号序列号相减转换成有符号序列号然后跟0比较
#### 3.确认号
1.不是所有的包都需要确认的
2.不是收到了数据包就立马需要确认的，可以延迟一会再确认
3.ACK 包本身不需要被确认，否则就会无穷无尽死循环了
4.确认号永远是表示小于此确认号的字节都已经收到
#### 4.FLAGS
1.我们的数据包通常有类型可以通过将flags中相应的标记位置为1即可
2.标记位可以组合存在常见的有SYN+ACK，FIN+ACK

 - SYN:用于发起连接数据包同步双方ISN
 - ACK:确认数据包
 - RST：强制断开连接
 - FIN：通知对方自己已发完了数据包，准备断开连接，后面不会继续发了
 - PSH：通知对方这些数据包收到后马上交给上层应用，不能缓存起来
 #### 5.窗口大小
 1.只有16位（65535字节）
 2.缩放前大小 * 2^n = 窗口真正大小
 #### 6.可选项
 MSS,Window Scale,Timestamps
 ###### Timestamps
 0.时间戳的值是单调递增的
 1.计算两端往返时延测量（RTTM）
 2.解决序列号回绕（PAWS）
 ## 三.知识点
 ### MTU(最大传输单元)
 0.工作于数据链路层
 1.以太网最大的帧是 1518 字节，除去 14 字节头部和 4 字节 CRC，有效荷载最大为 1500，这个值就是以太网的 MTU
 2.IP分段：当一个IP数据包大于MTU时，为了方便传输IP会把数据报文切分成小于MTU的多个小段
 3.路径MTU:一个包从发送端到接收端会经过多个不同的网络链路，每个链路的MTU可能都不同，把其中最小的MTU就称为路径MTU
 ### MSS
 0.工作于传输层
 1.TCP为了避免发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称为MSS
 2.MSS = MTU - IP header - TCP header
 ### 端口号
 1.如何查看某个端口号被哪个进程占用  netstat -ltpn | grep  port   或者 lsof -n -p  -i:port
 ### 半连接队列
 0.服务端调用listen函数时，TCP状态从CLOSE变为LISTEN，同时创建两个队列：半连接队列（SYN）和全连接队列（Accept）
 1.服务端收到客户端发送的SYN并回复ACK和发送SYN后悔将连接信息放到SYN队列中
 ### 全连接队列
 1.服务端收到客户端ACK后，socket处于ESTABLISHED状态，这时候服务器会将连接信息放入全连接队列，当应用调用accept函数将连接信息取走之后，连接信息就从全连接队列中移除
 2.全连接对满之后，如果客户端继续发送连接信息，会被服务器丢掉；只有Accept可以调走全连接队列中的链接信息
 ### SYN Flood攻击
#####  定义：
模仿虚拟IP，给服务端发送SYN请求，服务器给客户端回复SYN+ACK，结果客户端一脸懵逼说我没发，然后发送RST包
##### 解决方案
1.增加SYN连接数，调大net.ipv4.tcp_max_syn_backlog
2.减少SYN+ACK重试次数：tcp_synack_retries
3.SYN Cookie机制
### 惊群效应
##### 定义
多进程/多线程同时监听同一个套接字，当有网络事件发生时，所有等待的进程/线程同时被唤醒，但是只有其中一个进程/线程可以处理该网络事件，其他的获取失败重新进入休眠
##### 解决方案SO_REUSEPORT
1.实现了内核级别的负载均衡
2.支持滚动升级
### 快速关闭连接 SO_LINGER参数
### RST常见的几种情况
1.端口未监听：web服务器进程挂掉或者未启动
2.一方突然断电重启，之前建立的链接信息丢失
3.SO_LINGER 设置丢弃缓冲区数据，立刻 RST
### 快速重传
1.当发送端收到3个或以上重复ACK就意识到之前发的包可能丢失了，于是马上进行重传
2.SACK:再收到重复包的时候，同时携带收到包的序列段，就可以明确知道是哪些包丢失了
### 滑动窗口

## 四.三次握手
 1.客户端发送SYN报文，消耗一个序列号，为什么要消耗一个序列号？因为序列号是需要被确认的，握手需要服务端确认所以需要消耗一个序列号
 2.服务端收到SYN报文段后将SYN和ACK位置都标记置位，然后发送给客户端
 3.客户端发送最后一个ACK段报文
 
 4.三次握手过程会携带一些辅助信息，比如：MSS,窗口大小，窗口缩放因子，是否支持选择确认
 5.ISN之所以随机是为了防止，伪造RST包强制断开连接；动态增长的ISN在端口复用的情况下一定程度上保证数据不会混淆
 
 
 6.客户端发送建立连接请求后处于SYN-SENT状态，服务端处于LISTEN状态
 7.服务端发送ISN并回复ACK后处于SYN-RCVD状态
 8.客户端收到ACK后处于ESTABLISHED
 9.服务端收到ACK后处于ESTABLISHED
 ## 五.四次挥手
 ### 过程
 1.客户端发送FIN包   状态：ESTABLISHED -> FIN-WAIT-1
 2.服务端接收FIN包并发送ACK包  状态：ESTABLISHED - >CLOSE-WAIT
3. 客户端接收ACK包 状态：FIN-WAIT-1 -> FIN-WAIT-2
 4.服务端发送FIN包  状态： CLOSE-WAIT -> LAST-ACK
 5.客户端收到FIN包 状态：FIN-WAIT-2 -> TIME-WAIT(等待2MSL) -> CLOSED
 6.服务端收到ACK包 状态：LAST-ACK - >CLOSED
 ### 详细说明
 1.FIN段可以携带数据，但是发送FIN后不能再发送数据，但是可以接收数据，处于半连接状态
 2.四次握手是因为如果服务端接收到FIN不即时回复ACK有可能会造成客户端重发FIN包
 3.如果两端同时发送FIN包结果等待到的是彼此的FIN包而不是ACK包，此时状态从FIN-WAIT-1变成CLOSING状态
 ### MSL（报文最大生存时间）参数
 2MSL存在的意义：
 1.1个MSL保证，确保四次挥手中主动关闭方的ACK报文最终能达到对端
 2.1个MSL保证，对端没有收到ACK重传的FIN报文可以到达
 3.2MSL = 去向ACK消息最大存活时间 + 来向FIN消息的最大存活时间