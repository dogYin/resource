1.java编译器输入的指令流是基于栈的指令集架构，更好的跨平台；执行性能比寄存器差一点
2.不需要硬件支持，可移植性好，更好的实现跨平台

## 类加载子系统
1.主要负责从网络或者文件系统中加载class文件
2.加载后的类信息存放在方法区，除此之外方法区中还会存放运行时常量池信息
### 1. 加载
1.通过一个类的全限定名获取此类的二进制字节流
2.将字节流所代表的的静态储存结构转换为方法区的运行时数据结构
3.生成一个对应的java.lang.Class实例
### 2.链接
- 验证
	- 校验字节码是否符合规范
- 准备
	- 为类变量分配内存并设置类变量初始值
	- 不包含用final修饰的static常量
	- 不会为实例化变量分配
- 解析
	- 将符号引用转换为直接引用
### 3.初始化
1.就是执行类构造器方法过程，此方法不需要定义，会收集类变量并为其赋值
2.类变量是被static修饰的，才会被clinit方法执行
3.普通类变量的赋值操作时被init方法执行的，对应我们应用程序的构造器
## 类的加载器
### 1.Bootstrap ClassLoader
- 使用c语言实现，嵌套在jvm内部
- 用来加载java的核心库（rt,jar,resources.jar）
- 不继承自java.lang.ClassLoader，没有父加载器
- 只加载java、javax、sun等开头的
### 2.Extension ClassLoader
- java语言编写
- 派生于ClassLoader类
- 父类为Bootstarp ClassLoader
- 加载jre/lib/ext中的类
### 3.AppClassLoader
- java语言编写
- 派生于ClassLoader类
- 父类为Extension ClassLoader
- 加载classpath下的类应用 程序默认的类加载器
### 4.自定义类加载器
用处：
- 隔离加载类
- 修改类的加载方式
- 扩展加载源
- 防止源码泄露

实现方式：
- 继承ClassLoader
- 覆盖findClass方法
- 也可以直接继承URLClassLoader避免自己去编写findClass()方法

## 双亲委派模型
### 1.工作原理
- 如果一个类收到了类加载请求，并不会自己去加载而是委托给父类去加载
- 如果父类加载器还存在其父类加载器，则向上继续委托，直到到达最顶层
- 如果父类能完成加载，就会加载，如果父类无法加载子类会尝试自己去加载
### 2.打破双亲委派
- 自定义类加载器，重写loadClass方法
- 使用线程上下文类加载器
