策略模式：
    思考：java中的BufferedReader->装饰者模式
    需求：新的需求的添加，不一定所有的子类都要实现
        通过继承实现带来的问题：对类的局部改动，尤其是超类的局部改动，会影响其他部分，影响会有溢出效应
        OO原则实现：也会带来溢出效应
        总结：超类挖一个坑，每个子类都要填，增加工作量，复杂度o(n^2)

    需要新的设计方式，应对项目的扩展性，降低复杂度
        （1）.分析项目变化与不变的部分，提取变化的部分，抽象成接口+实现
        （2）.
    通过策略模式解决：
        分别封装行为为接口，实现算法簇，超类里放行为接口对象，在子类里具体设定行为对象。
        原则：分离变化的部分，封装接口，基于接口编程各种功能改模式让行为算法的变化独立于算法的使用者
        注意：分析项目中变化和不变化的部分
            ：多用组合少用继承；用行为类组合，而不是行为的继承更有弹性
    
    使用：即业务的根据不同条件走向不同 大量的if else 可以考虑是否能抽成策略模式解决


观察者模式：
     项目：Internet气象站项目
        提供温度、气压和湿度的接口
        测量数据更新实时通知给第三方
        需要设计开放型API，便于其他第三方公司也能接入气象站获取数据
         
    1.观察者就像订牛奶
        1）.奶站，subject
        2）.用户，Observer（观察者）
    2、Subject：登记注册、移除和通知
    3、Observer： 接收输入

    定义：对象之间多对一依赖的一种设计方案，被依赖对象为subject，依赖对象为observer，subject通知observer变化